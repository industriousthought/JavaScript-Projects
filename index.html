<html>

 <head>

 <title>ANN</title>

 <script type='text/javascript'>


//Array clone prototype function

	Array.prototype.clone = function() {

		var newObj = this.slice(0);
	
		for (i=0; i<this.length; i++) {

			if (this[i].clone) {

				newObj[i] = this[i].clone();
				break;
			}
		}

		return newObj;

	}


//Set up global variables


	var xCoefficient = 0;
	var yCoefficient = 0;

//Boolean switch, trigger to dump properties for trouble-shooting
	var dump=0;

//This sets which substance to display on the grid. Set to zero for none.
	var currentSource = 0;


//Height and width values for browser window.
	var myHeight = 0;
	var myWidth = 0;

//An array that contains the settings for different substances.  Will contains substance objects.
	var sources = new Array();

//A three-dimensional array that contains the levels for each substance at each point on the grid.
	var grid = new Array();

//As the substance diffussion pattern is calculated the results are placed in this array. At the end
//of the iteration, this is cloned back to grid[]
	var newGrid = new Array();


//An array of bacterium objects. 
	var germs = new Array();






//step through a neuralNetwork object and return html with data on neural configuration
	function viewNetwork(netObj) {
		
//setup the final variable to be returned
		htmlOut = '';

//Step through the whole network array in neuralNetwork object
		for (x=0; x<netObj.network.length; x++) {
			
//output the layer number at the start of each x value
			htmlOut = htmlOut + 'layer ' + x + ' - ';

//step through each neuron on the current layer
			for (y=0; y<netObj.network[x].length; y++) {

//output the neuron number and activationThreshold for each neuron
				htmlOut = htmlOut + y + ' - ' + netObj.network[x][y].activationThreshold + '(';


//step through the synapses array in the current neuron object
				for (i=0; i<netObj.network[x][y].synapses.length; i++) {


//output the destination and weight for each synapse. the synapse values will be deliniated by commas
//and the whole group for the neuron will be bracketed by parathesis
					htmlOut = htmlOut + netObj.network[x][y].synapses[i].destination + ' - ' + netObj.network[x][y].synapses[i].weight + ', ';

				}			

				htmlOut = htmlOut + ')';

			}
		
//do a few line breaks between layers
			htmlOut = htmlOut + '<br><br>';

		}

		return htmlOut;

	}


//Builds a pattern for an ANN that the neuralNetwork object can take as a parameter
//the pattern is a generic layout for a neural configuration without specific neural activationThresholds or synaptic weights
//metaPattern is a one dimension array.  
	function buildNeuralPattern(metaPattern, synapticDensityFactor) {


//a three-dimensional array that can be passed to the neuralNetwork constructor.  
		var outputArray = new Array();

//sets up the number of synapses for each neuron.  If there are fewer neurons in the downstream layer than 
//synaptic connections, set to the number of neurons in that layer. 
		var workingDensityFactor = 0;


		for (x=0; x<metaPattern.length; x++) {

			outputArray[x] = new Array();

			if (x < metaPattern.length - 1) {

				if (synapticDensityFactor > metaPattern[x+1]) {

					workingDensityFactor = metaPattern[x+1];

				} else {

					workingDensityFactor = synapticDensityFactor;

				}
			}

			for (y=0; y<metaPattern[x]; y++) {

				if (x < metaPattern.length - 1) {

					outputArray[x][y] = new Array();

					if (y < (workingDensityFactor / 2)) {

						ii = 0;

					} else if (y > (metaPattern[x+1] - Math.floor(.5 * workingDensityFactor))) {

						ii = metaPattern[x+1] - workingDensityFactor;

					} else {

						ii = Math.floor(y - workingDensityFactor / 2);

					}

					
					for (i=0; i<workingDensityFactor; i++) {

						outputArray[x][y][i] = ii;
						ii++;

					}

				} else {
			
				outputArray[x][y] = 0;

				}
			}
		}
	
	return outputArray;

	}


//synapse object. Will be instanciated by nueron object.************************* 
	function synapse(destination, weight) {

//Properties of synapse object. 

//wieght is a multiplier that will be applied to activation voltage from the upstream neuron.
		this.weight = weight;
//destination of downstream neuron this synapse connects to.
		this.destination = destination;

	}




//neuron object. Will be instanciated by neuralNetwork object********************
	function neuron(synapseData, activationThreshold) {
		
//Properties of neuron object



		this.currentState = 0;
//synapses is an array of synapse objects
		this.synapses = new Array();
//activationThreshold is the value at which the neuron fires when the sum of upstream synapses reaches it
		this.activationThreshold = activationThreshold;

//This loop cycles through an array of synapse data and uses it to populate the synapses array with synapse objects
		for (i=0; i<synapseData.length; i++) {

			this.synapses[i] = new synapse(synapseData[i][0], synapseData[i][1]);

		}

	}




//neuralNetwork object. ****************************************************
	function neuralNetwork(neurons, pattern) {


		this.evaluate = function(inputArray) {

			var outputArray = new Array();

			for (i=0; i<inputArray.length; i++) {

				network[0][i].currentState = inputArray[i];

			}

			for (x=0; x<network.length-1; x++) {
		
				for (y=0; y<network[x].length; y++) {
		
					for (i=0; i<network[x][y].synapses.length; i++) {

						if (x == 0 || network[x][y].currentState >= network[x][y].activationThreshold) {

							network[x+1][network[x][y].synapses[i].destination].currentState = network[x+1][network[x][y].synapses[i].destination].currentState + (network[x][y].currentState * (network[x][y].synapses[i].weight / 100));

						}
					}

				}
	
			}

			for (x=0; x<network[network.length-1].length; x++) {

				outputArray = network[network.length-1][x].currentState;

			}

			return outputArray;

		}

//network is an array of neuron objects
		this.network = new Array();

//These nested loops cycle through the network data and uses it to populate an array with neuron objects.

		if (neurons != null && pattern == null) {
			for (x=0; x<neurons.length; x++) {

				this.network[x] = new Array();

				for (y=0; y<neurons[x].length; y++) {
			
					this.network[x][y] = new neuron(neurons[x][y][0], neurons[x][y][1]);
				}

			}
		}

		if (neurons == null && pattern != null) {
		

			synapseData = new Array();
		
			for (x=0; x<pattern.length; x++) {

				this.network[x] = new Array();
				
				for (y=0; y<pattern[x].length; y++) {


					synapseData.length = 0;			

					for (i=0; i<pattern[x][y].length; i++) {

						synapseData[i] = new Array(pattern[x][y][i], Math.floor(Math.random()*100));
						

					}

					this.network[x][y] = new neuron(synapseData, Math.floor(Math.random()*100));
				}


			}

		}
	}


	



//bacterium object. ***************************************************************
	function bacterium(x, y, i) {

//Displays germ image in correct location on the grid
		addImg('germ' + i, 'germ.gif', x, y);

//Properties for bacterium object

		this.cellDeath = false;

//Tracks number of iterations
		this.counter = 0;
//ATP level for bacterium.
		this.atp = 20;
//Integrity of cell wall
		this.cellWall = 100;
//Protein level
		this.protein = 20;
//X-coordinate for position
		this.x = x;
//Y-coordinate for position
		this.y = y;
		this.i = i;

		document.getElementById('germ' + i).onclick = function() {

			document.getElementById('inspector').innerHTML = 'atp ' + germs[i].atp + '<br>Protein ' + germs[i].protein + '<br>Cellwall ' + germs[i].cellWall + '<br>counter ' + germs[i].counter;

		}


	}




	function bacIterate(parentObj) {


//Increment the counter on each iteration
		parentObj.counter++;


//Get average values for substances around bacterium		
		avgGlucose = sumArray(surroundingSample(Math.floor(parentObj.x), Math.floor(parentObj.y), 1)) / 8;
		avgProtein = sumArray(surroundingSample(Math.floor(parentObj.x), Math.floor(parentObj.y), 2)) / 8;
		avgCilian = sumArray(surroundingSample(Math.floor(parentObj.x), Math.floor(parentObj.y), 3)) / 8;
//			avgCaffeine = sumArray(surroundingSample(parentObj.x, parentObj.y, 4)) / 8;


//Only aquire atp if levels within bacterium are below 200
		if (parentObj.atp < 200) {

//if avgGlucose is less than or equal to one absorb glucose at slighly lower level
			if (avgGlucose <= 1) {
				parentObj.atp = parentObj.atp + (avgGlucose * 5);
			}				

//if avgGlucose is between one and two absorb at a slightly higher level
			if (avgGlucose > 1 && avgGlucose < 2) {
				parentObj.atp = parentObj.atp + (avgGlucose * 7);
			}	

//Absorb a maximum of 14 atp per interation
			if (avgGlucose >= 2) {
				parentObj.atp = parentObj.atp + (2 * 7);
			}
		}


//Only aquire protein if levels within bacterium are below 200
		if (parentObj.protein < 200) {

//if avgProtein is less than or equal to one absorb protein at slighly lower level
			if (avgProtein <= 1) {
				parentObj.protein = parentObj.protein + (avgProtein * 5);
			}

//if avgProtein is between one and two absorb at a slightly higher level
			if (avgProtein > 1 && avgProtein < 2) {
				parentObj.protein = parentObj.protein + (avgProtein * 7);
			}

//Absorb a maximum of 14 protein per interation
			if (avgProtein >= 2) {
				parentObj.protein = parentObj.protein + (2 * 7);
			}
		}
			



//if avgCilian is less than or equal to one absorb protein at slighly lower level
		if (avgCilian <= 1) {
			parentObj.cellWall = parentObj.cellWall - (avgCilian * 5);
		}

//if avgCilian is between one and two absorb at a slightly higher level
		if (avgCilian > 1 && avgCilian < 2) {
			parentObj.cellWall = parentObj.cellWall - (avgCilian * 7);
		}

//if avgCilian is greater than two absorb at a much higher level
		if (avgCilian >= 2) {
			parentObj.cellWall = parentObj.cellWall - (avgCilian * 15);
		}




		if (parentObj.cellWall < 100 && parentObj.cellWall > 90) {

			parentObj.atp = parentObj.atp - ((100 - parentObj.cellWall) / 5);
			parentObj.protein = parentObj.protein - ((100 - parentObj.cellWall) / 5);
			parentObj.cellWall = parentObj.cellWall + ((100 - parentObj.cellWall) / 5)

		}

		if (parentObj.cellWall <= 90 && parentObj.cellWall > 70) {

			parentObj.atp = parentObj.atp - ((100 - parentObj.cellWall) / 3);
			parentObj.protein = parentObj.protein - ((100 - parentObj.cellWall) / 3);
			parentObj.cellWall = parentObj.cellWall + ((100 - parentObj.cellWall) / 4)

		}

		if (parentObj.cellWall <= 70) {

			parentObj.atp = parentObj.atp - ((100 - parentObj.cellWall) / 2);
			parentObj.protein = parentObj.protein - ((100 - parentObj.cellWall) / 2);
			parentObj.cellWall = parentObj.cellWall + ((100 - parentObj.cellWall) / 3)

		}


		if (parentObj.cellWall <= 50) {

			parentObj.cellDeath = true;

		}

		angle = Math.random()*360;
		distance = Math.random();

		if (angle != 0) {
			angle = Math.PI * (angle / 180);
		} else {
	
			angle = 0;
		}


		xoffset = Math.cos(angle) * distance;

		if (angle > Math.PI) {

			yoffset = Math.sqrt((distance * distance) - (xoffset * xoffset));

		} else {

			yoffset = 0 - (Math.sqrt((distance * distance) - (xoffset * xoffset)));

		}
		parentObj.x = parentObj.x - xoffset;
		parentObj.y = parentObj.y + yoffset;

		if (parentObj.x > 30) {
			parentObj.x = parentObj.x - 30;
		}

		if (parentObj.y > 30) {
			parentObj.y = parentObj.y - 30;
		}

		if (parentObj.x < 0) {
			parentObj.x = parentObj.x + 30;
		}

		if (parentObj.y < 0) {
			parentObj.y = parentObj.y + 30;
		}

		document.getElementById('germ' + parentObj.i).style.top = Math.round((myHeight / 35) * parentObj.x);
		document.getElementById('germ' + parentObj.i).style.left = Math.round((myWidth / 50) * parentObj.y);


//			document.getElementById('inspector').innerHTML = 'atp ' + this.atp + '<br>Protein ' + this.protein + '<br>Cellwall ' + this.cellWall + '<br>avgGlucose ' + avgGlucose + '<br>avgProtein ' + avgProtein + '<br>avgCilian ' + avgCilian + '<br>counter ' + counter;
	
	}


	function source(type, intensity, x, y, decay) {


		this.decay = decay / 100;
		this.type = type;
		this.intensity = intensity;
		this.x = x;
		this.y = y;


	}


	function addImg(id, src, x, y) {


		getSize();


		var newLocation = document.createElement('img');
		newLocation.setAttribute('id', id);
		newLocation.setAttribute('src', src);
		document.getElementById('display').appendChild(newLocation);
		var currentLocation = document.getElementById(id);
		currentLocation.style.top = Math.round((myHeight / 35) * x);
		currentLocation.style.left = Math.round((myWidth / 50) * y);
		currentLocation.style.position = 'absolute';
		currentLocation.height = Math.round(myHeight / 34);
		currentLocation.width = Math.round(myWidth / 49);



	}


	function setupGrid() {



		for (i=0; i<4; i++) {

			if (i > 0) {
				sources[i] = new source(i, /*Math.floor(Math.random()*100)*/ 90, Math.floor(Math.random()*30), Math.floor(Math.random()*30), 10);
			}

			var buttonHTML = '<input type=\"radio\" name=\"sourceButtons\" id=\"sourceButton' + i + '\" onClick=\"currentSource=' + i + '\"> ' + i + '<br>';
			document.getElementById('controlPanel').innerHTML = document.getElementById('controlPanel').innerHTML + buttonHTML;

		}

	
		for (x=0; x<30; x++)	{
		
			grid[x] = new Array();
			newGrid[x] = new Array();
	
			for (y=0; y<30; y++)	{

				addImg('location' + x + '-' + y, 'dot.gif', x, y);
	
				grid[x][y] = new Array(0,0,0,0,0,0);
				newGrid[x][y] = new Array(0,0,0,0,0,0);
			
						
	
			}
		}

		for (i=0; i<5; i++) {

			germs[i] = new bacterium( Math.floor(Math.random()*30),  Math.floor(Math.random()*30), i);
		}


	}


	function cycleTime() {

		difussion();

		for (i=0; i<germs.length; i++) {
			ii = i;
			if (germs[i]) {

				if (germs[i].cellDeath == false) {

					bacIterate(germs[i]);
	
				} else {
	
					document.getElementById('germ' + i).height = 0;
					document.getElementById('germ' + i).width = 0;
					delete germs[i];
				}


			}
			i = ii;

		}

		
	
		for (i=1; i<sources.length; i++) {
		
			newGrid[sources[i].x][sources[i].y][i] = sources[i].intensity;

		}


		grid = newGrid.clone();


	}
		
	function difussion() {


		for (x=0; x<grid.length; x++) {

			for (y=0; y<grid[x].length; y++)  {

				for (i=1; i<sources.length; i++) {

					if (dump) {
						alert(grid[x][y][i]);
						dump = 0;
					}

					ii = i;

					currentDecay = sources[i].decay;
				

					
					
					newGrid[x][y][i] = sumArray(surroundingSample(x, y, i)) / (8 + currentDecay);


					if (currentSource > 0) {
						document.getElementById('location' + x + '-' + y).style.opacity = newGrid[x][y][currentSource] / 100;
						document.getElementById('location' + x + '-' + y).style.filter = 'alpha(opacity=' + newGrid[x][y][currentSource] + ')';
					} else {
						document.getElementById('location' + x + '-' + y).style.opacity = 0;
						document.getElementById('location' + x + '-' + y).style.filter = 'alpha(opacity=0)';
					}
					
					i = ii;

				}

			

				
			}
		}



	}



	function surroundingSample(x, y, i) {

		

		if (x != 0 && y != 0 && x != grid.length - 1 && y != grid[i].length - 1) {
			var surroundPattern = new Array(grid[x - 1][y][i], grid[x][y - 1][i], grid[x - 1][y - 1][i], grid[x - 1][y + 1][i], grid[x + 1][y - 1][i], grid[x + 1][y][i], grid[x][y + 1][i], grid[x + 1][y + 1][i]);
		}

		if (x == 0 && y == 0) {
			var surroundPattern = new Array(grid[grid.length - 1][y][i], grid[x][grid[x].length - 1][i], grid[grid.length - 1][grid[x].length - 1][i], grid[grid.length - 1][y + 1][i], grid[x + 1][grid[x].length - 1][i], grid[x + 1][y][i], grid[x][y + 1][i], grid[x + 1][y + 1][i]);
		}					

		if (x == grid.length - 1 && y == grid[x].length - 1) {
			var surroundPattern = new Array(grid[x - 1][y][i], grid[x][y - 1][i], grid[x - 1][y - 1][i], grid[x - 1][0][i], grid[0][y - 1][i], grid[0][y][i], grid[x][0][i], grid[0][0][i]);
		}					

		if (x == 0 && y == grid[x].length - 1) { 
			var surroundPattern = new Array(0, 0, 0, 0, 0, 0, 0, 0); //(grid[grid.length - 1][y][i], grid[x][y - 1][i], grid[grid.length - 1][y - 1][i], grid[grid.legnth - 1][0][i], grid[x + 1][y - 1][i], grid[x + 1][y][i], grid[x][0][i], grid[x + 1][0][i]);
		}

		if (x == grid.length - 1 && y == 0) {
			var surroundPattern = new Array(grid[0][y][i], grid[x][grid[x].length - 1][i], grid[x - 1][grid[x].length - 1][i], grid[x - 1][y + 1][i], grid[0][grid[x].length - 1][i], grid[0][y][i], grid[x][y + 1][i], grid[grid[x].length - 1][y + 1][i]);
		}

		if (y == 0 && x != 0 && x != grid.length - 1) {
			var surroundPattern = new Array(grid[x - 1][y][i], grid[x][grid[x].length - 1][i], grid[x - 1][grid[x].length - 1][i], grid[x - 1][y + 1][i], grid[x + 1][grid[x].length - 1][i], grid[x + 1][y][i], grid[x][y + 1][i], grid[x + 1][y + 1][i]);
		}

		if (y == grid[x].length - 1 && x != 0 && x != grid.length - 1) {
			var surroundPattern = new Array(grid[x - 1][y][i], grid[x][y - 1][i], grid[x - 1][y - 1][i], grid[x - 1][0][i], grid[x + 1][y - 1][i], grid[x + 1][y][i], grid[x][0][i], grid[x + 1][0][i]);
		}

		if (x == grid.length - 1 && y != 0 && y != grid.length - 1) {
			var surroundPattern = new Array(grid[x - 1][y][i], grid[x][y - 1][i], grid[x - 1][y - 1][i], grid[x - 1][y + 1][i], grid[0][y - 1][i], grid[0][y][i], grid[x][y + 1][i], grid[0][y + 1][i]);
		}

		if (x == 0 && y != 0 && y != grid.length - 1) {
			var surroundPattern = new Array(grid[grid.length - 1][y][i], grid[x][y - 1][i], grid[grid.length - 1][y - 1][i], grid[grid.length - 1][y + 1][i], grid[x + 1][y - 1][i], grid[x + 1][y][i], grid[x][y + 1][i], grid[x + 1][y + 1][i]);
		}
		

		return surroundPattern;


	}

	function sumArray(inputArray) {

		var total = 0;
	
		for (i=0; i<inputArray.length; i++) {

			total = total + inputArray[i];
	
		}
	
		return total;

	}

function getSize() {
	if( typeof( window.innerWidth ) == 'number' ) {
	//Non-IE
	myWidth = window.innerWidth;
	myHeight = window.innerHeight;
	} else if( document.documentElement && ( document.documentElement.clientWidth || document.documentElement.clientHeight ) ) {
	//IE 6+ in 'standards compliant mode'
	myWidth = document.documentElement.clientWidth;
	myHeight = document.documentElement.clientHeight;
	} else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
	//IE 4 compatible
	myWidth = document.body.clientWidth;
	myHeight = document.body.clientHeight;
  }
}


 </script>

<style>
<!--

#display {
width:100%;
height:100%
}

#controlPanel {
position: absolute;
top: 10px;
right: 10px;
}

#inspector {
position: absolute;
top: 10px;
right: 50px;
}

#inspector2 {
position: absolute;
bottom: 100px;
right: 50px;
height: 100px;
}

-->
</style>


 </head>


<body onLoad="setupGrid();">

<div id="display">
</div>

<div id="controlPanel">
<a href="#" onClick="dump=5;">dump</a><br>
</div>

<div id="inspector">
</div>

<script>


/*
testNetArray = new Array(3, 4, 5, 6, 7, 8);


testNetObj = new neuralNetwork(null, buildNeuralPattern(testNetArray, 6));


document.getElementById('inspector').innerHTML = viewNetwork(testNetObj);

*/

window.setInterval('cycleTime()', 0);

</script>

</body>


</html>

